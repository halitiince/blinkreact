import * as fs from 'fs';
import * as path from 'path';
import { RenderMetrics } from '../analyzer/renderAnalyzer';
import { StateMetrics } from '../analyzer/stateAnalyzer';

interface ReportData {
  componentName: string;
  componentPath: string;
  renderMetrics: RenderMetrics;
  stateMetrics: StateMetrics;
}

/**
 * Generate a performance report for a React component
 * @param data Report data
 */
export async function generateReport(data: ReportData): Promise<void> {
  const reportContent = `
# BlinkReact Performance Report

## Component: \`${data.componentName}\`

**File Path:** \`${data.componentPath}\`  
**Analysis Date:** ${new Date().toLocaleString()}

## Render Performance

- **Total Renders:** ${data.renderMetrics.totalRenders}
- **Average Render Time:** ${data.renderMetrics.averageRenderTime.toFixed(2)}ms
- **Maximum Render Time:** ${data.renderMetrics.maxRenderTime.toFixed(2)}ms
- **Unnecessary Renders:** ${data.renderMetrics.unnecessaryRenders}

### Render Time Details

| Render # | Duration (ms) |
|----------|---------------|
${data.renderMetrics.renderTimes.map((time, index) => `| ${index + 1} | ${time.toFixed(2)} |`).join('\n')}

## State Management

- **Total State Updates:** ${data.stateMetrics.totalStateUpdates}
- **Redundant State Updates:** ${data.stateMetrics.redundantStateUpdates}

### State Update Details

| State Variable | Update Count | Redundant Updates |
|----------------|--------------|-------------------|
${data.stateMetrics.stateUpdateDetails.map(state => 
  `| \`${state.stateName}\` | ${state.updateCount} | ${state.redundantUpdates} |`
).join('\n')}

## Performance Recommendations

${generateRecommendations(data)}

---

*Generated by BlinkReact - React Performance Analysis Tool*
`;

  // Write the report to a file
  fs.writeFileSync('PERFORMANCE_REPORT.md', reportContent);
}

/**
 * Generate performance recommendations based on analysis
 * @param data Report data
 * @returns Recommendations as a string
 */
function generateRecommendations(data: ReportData): string {
  const recommendations: string[] = [];
  
  // Check for unnecessary renders
  if (data.renderMetrics.unnecessaryRenders > 0) {
    recommendations.push(
      '- **Reduce Unnecessary Renders:** Consider using `React.memo()` to prevent re-renders when props haven\'t changed.'
    );
  }
  
  // Check for slow renders
  if (data.renderMetrics.maxRenderTime > 10) {
    recommendations.push(
      '- **Optimize Render Performance:** The component has slow renders. Consider breaking it down into smaller components or optimizing expensive calculations with `useMemo()`.'
    );
  }
  
  // Check for redundant state updates
  if (data.stateMetrics.redundantStateUpdates > 0) {
    recommendations.push(
      '- **Reduce Redundant State Updates:** The component has redundant state updates. Consider using functional updates or the `useReducer` hook for more complex state logic.'
    );
  }
  
  // Check for many state variables
  if (data.stateMetrics.stateUpdateDetails.length > 3) {
    recommendations.push(
      '- **Consolidate State:** The component has many state variables. Consider using `useReducer` to manage related state together.'
    );
  }
  
  // Add general recommendations
  recommendations.push(
    '- **Use Callback Memoization:** Consider using `useCallback()` for event handlers to prevent unnecessary re-renders of child components.',
    '- **Virtualize Long Lists:** If the component renders lists, consider using virtualization libraries like `react-window` to render only visible items.'
  );
  
  return recommendations.join('\n\n');
} 